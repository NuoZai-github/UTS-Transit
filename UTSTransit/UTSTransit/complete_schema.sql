-- ==========================================
-- UTS Transit - Complete Database Schema (Idempotent)
-- ==========================================

-- -----------------------------------------------------------------------------
-- 1. PROFILES & AUTHENTICATION
-- -----------------------------------------------------------------------------

-- Create a 'profiles' table to store user data safely
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  email text,
  role text, -- 'student', 'driver', 'admin'
  student_id text,
  ic_number text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure columns exist if table was already created
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS student_id text;
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS ic_number text;

-- Enable Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to avoid conflicts
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;

-- Create Policies for Profiles
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles
  FOR SELECT USING (true);

CREATE POLICY "Users can insert their own profile." ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile." ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

-- Create/Replace the function that handles new user registration
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email, role, student_id, ic_number)
  VALUES (
    new.id, 
    new.email, 
    COALESCE(new.raw_user_meta_data->>'role', 'student'),
    new.raw_user_meta_data->>'student_id',
    new.raw_user_meta_data->>'ic_number'
  );
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate the Trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- -----------------------------------------------------------------------------
-- 2. ACTIVE TRIPS (LIVE MAP)
-- -----------------------------------------------------------------------------

-- Create the 'active_trips' table
CREATE TABLE IF NOT EXISTS public.active_trips (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  driver_id uuid REFERENCES auth.users NOT NULL,
  route_name text NOT NULL,
  latitude double precision NOT NULL,
  longitude double precision NOT NULL,
  status text DEFAULT 'Stopped', -- 'Moving', 'Stopped', 'Delayed'
  last_updated timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable Row Level Security (RLS)
ALTER TABLE public.active_trips ENABLE ROW LEVEL SECURITY;

-- Drop existing policies
DROP POLICY IF EXISTS "Enable read access for all users" ON public.active_trips;
DROP POLICY IF EXISTS "Enable insert for users based on user_id" ON public.active_trips;
DROP POLICY IF EXISTS "Enable update for users based on user_id" ON public.active_trips;
DROP POLICY IF EXISTS "Enable delete for users based on user_id" ON public.active_trips;

-- Create Policies
-- Policy 1: Allow everyone (authenticated or anonymous) to view bus locations
CREATE POLICY "Enable read access for all users"
ON public.active_trips FOR SELECT USING (true);

-- Policy 2: Allow authenticated users to insert their own location
CREATE POLICY "Enable insert for users based on user_id"
ON public.active_trips FOR INSERT WITH CHECK (auth.uid() = driver_id);

-- Policy 3: Allow users to update their own location
CREATE POLICY "Enable update for users based on user_id"
ON public.active_trips FOR UPDATE USING (auth.uid() = driver_id)
WITH CHECK (auth.uid() = driver_id);

-- Policy 4: Allow users to delete their own location (Stop Sharing)
CREATE POLICY "Enable delete for users based on user_id"
ON public.active_trips FOR DELETE USING (auth.uid() = driver_id);

-- Enable Realtime for Live Map
-- Safely add table to publication only if not already present
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_publication_rel pr
    JOIN pg_class pc ON pr.prrelid = pc.oid
    JOIN pg_publication pp ON pr.prpubid = pp.oid
    WHERE pp.pubname = 'supabase_realtime' AND pc.relname = 'active_trips'
  ) THEN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.active_trips;
  END IF;
END $$;


-- -----------------------------------------------------------------------------
-- 3. ADMIN FEATURES (ANNOUNCEMENTS, SCHEDULES, PASSENGERS)
-- -----------------------------------------------------------------------------

-- Create Announcements Table
CREATE TABLE IF NOT EXISTS public.announcements (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_urgent BOOLEAN DEFAULT FALSE
);

-- Create Schedules Table
CREATE TABLE IF NOT EXISTS public.schedules (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    route_name TEXT NOT NULL,
    departure_time TIME NOT NULL,
    day_type TEXT DEFAULT 'Weekday', -- 'Weekday', 'Weekend'
    status TEXT DEFAULT 'Scheduled' -- 'Scheduled', 'Delayed', 'Cancelled'
);

-- Create Trip Passengers Table (for tracking students on buses)
CREATE TABLE IF NOT EXISTS public.trip_passengers (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    trip_id BIGINT REFERENCES public.active_trips(id) ON DELETE CASCADE, 
    student_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    boarded_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- Enable RLS
ALTER TABLE public.announcements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trip_passengers ENABLE ROW LEVEL SECURITY;

-- Drop existing policies
DROP POLICY IF EXISTS "Everyone can read announcements" ON public.announcements;
DROP POLICY IF EXISTS "Admins can manage announcements" ON public.announcements;
DROP POLICY IF EXISTS "Everyone can read schedules" ON public.schedules;
DROP POLICY IF EXISTS "Admins can manage schedules" ON public.schedules;
DROP POLICY IF EXISTS "Students can board" ON public.trip_passengers;
DROP POLICY IF EXISTS "Everyone can read passengers" ON public.trip_passengers;

-- RLS Policies

-- Announcements: Everyone can read, only Admins can insert/update/delete
CREATE POLICY "Everyone can read announcements" ON public.announcements FOR SELECT USING (true);

CREATE POLICY "Admins can manage announcements" ON public.announcements FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Schedules: Everyone can read, only Admins can manage
CREATE POLICY "Everyone can read schedules" ON public.schedules FOR SELECT USING (true);

CREATE POLICY "Admins can manage schedules" ON public.schedules FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Trip Passengers: 
-- Students can insert themselves (boarding)
CREATE POLICY "Students can board" ON public.trip_passengers FOR INSERT WITH CHECK (auth.uid() = student_id);
-- Everyone can read (for Admin monitoring and maybe driver)
CREATE POLICY "Everyone can read passengers" ON public.trip_passengers FOR SELECT USING (true);


-- -----------------------------------------------------------------------------
-- 4. SEED DATA (INITIAL CONTENT)
-- -----------------------------------------------------------------------------

-- Use INSERT ON CONFLICT DO NOTHING or checks to avoid duplicate data if run multiple times
-- Since these tables don't have unique constraints on content, we might duplicate data if run repeatedly.
-- Ideally, truncate or check existence. For simplicity in dev, we will just insert.
-- Users can manually clear tables if needed: TRUNCATE public.schedules;

INSERT INTO public.schedules (route_name, departure_time, day_type) 
SELECT 'Route A (Dorm -> Campus)', '07:30', 'Weekday'
WHERE NOT EXISTS (SELECT 1 FROM public.schedules WHERE route_name = 'Route A (Dorm -> Campus)' AND departure_time = '07:30');

INSERT INTO public.schedules (route_name, departure_time, day_type) 
SELECT 'Route A (Dorm -> Campus)', '08:30', 'Weekday'
WHERE NOT EXISTS (SELECT 1 FROM public.schedules WHERE route_name = 'Route A (Dorm -> Campus)' AND departure_time = '08:30');

INSERT INTO public.schedules (route_name, departure_time, day_type) 
SELECT 'Route B (Campus -> Hostel)', '07:45', 'Weekday'
WHERE NOT EXISTS (SELECT 1 FROM public.schedules WHERE route_name = 'Route B (Campus -> Hostel)' AND departure_time = '07:45');

INSERT INTO public.schedules (route_name, departure_time, day_type) 
SELECT 'Route B (Campus -> Hostel)', '08:45', 'Weekday'
WHERE NOT EXISTS (SELECT 1 FROM public.schedules WHERE route_name = 'Route B (Campus -> Hostel)' AND departure_time = '08:45');

INSERT INTO public.announcements (title, content, is_urgent) 
SELECT 'Welcome to UTS Transit', 'The new app is live! Check schedules and track buses.', FALSE
WHERE NOT EXISTS (SELECT 1 FROM public.announcements WHERE title = 'Welcome to UTS Transit');

INSERT INTO public.announcements (title, content, is_urgent) 
SELECT 'Maintenance Notice', 'Bus A will be under maintenance this Sunday.', TRUE
WHERE NOT EXISTS (SELECT 1 FROM public.announcements WHERE title = 'Maintenance Notice');
